#ifndef PDS_TRIGGER_DDL_H
#define PDS_TRIGGER_DDL_H 1

// *** Do not edit this file, it is auto-generated ***

#include <vector>
#include <iosfwd>
#include <cstddef>
#include <cstring>
#include "pdsdata/xtc/TypeId.hh"
#include "ndarray/ndarray.h"
namespace Pds {
namespace TriggerData {

/** @class PulseConfigV1

  
*/


class PulseConfigV1 {
public:
  PulseConfigV1(uint16_t arg__outputs, uint32_t arg__delay, uint32_t arg__width)
    : _outputs(arg__outputs), _delay(arg__delay), _width(arg__width)
  {
  }
  PulseConfigV1() {}
  /** trigger signal outputs (bit mask) */
  uint16_t outputs() const { return _outputs; }
  /** delay in 119MHz clks */
  uint32_t delay() const { return _delay; }
  /** width in 119MHz clks */
  uint32_t width() const { return _width; }
  static uint32_t _sizeof() { return 12; }
private:
  uint16_t	_outputs;	/**< trigger signal outputs (bit mask) */
  uint16_t	_polarity;	/**< pulse polarity */
  uint32_t	_delay;	/**< delay in 119MHz clks */
  uint32_t	_width;	/**< width in 119MHz clks */
};

/** @class ModuleV1

  
*/

#pragma pack(push,4)

class ModuleV1 {
public:
  enum { NPulses = 12 };
  ModuleV1(const TriggerData::PulseConfigV1* arg__pulses)
  {
    if (arg__pulses) std::copy(arg__pulses, arg__pulses+(12), &_pulses[0]);
  }
  ModuleV1() {}
  /**     Note: this overloaded method accepts shared pointer argument which must point to an object containing
    this instance, the returned ndarray object can be used even after this instance disappears. */
  template <typename T>
  ndarray<const TriggerData::PulseConfigV1, 1> pulses(const boost::shared_ptr<T>& owner) const { 
    const TriggerData::PulseConfigV1* data = &_pulses[0];
    return make_ndarray(boost::shared_ptr<const TriggerData::PulseConfigV1>(owner, data), NPulses);
  }
  /**     Note: this method returns ndarray instance which does not control lifetime
    of the data, do not use returned ndarray after this instance disappears. */
  ndarray<const TriggerData::PulseConfigV1, 1> pulses() const { return make_ndarray(&_pulses[0], NPulses); }
  static uint32_t _sizeof() { return ((((0+(TriggerData::PulseConfigV1::_sizeof()*(NPulses)))+4)-1)/4)*4; }
private:
  TriggerData::PulseConfigV1	_pulses[NPulses];
};
#pragma pack(pop)

/** @class L0SelectV1

  
*/

#pragma pack(push,4)

class L0SelectV1 {
public:
  enum RateSelect {
    _FixedRate,
    _PowerSyncRate,
    _ControlSequence,
    _EventCode, /**< LCLS-I */
    _Partition,
  };
  enum Destination {
    _HXU = 0x1,
    _SXU = 0x2,
    _DumpBsy = 0x4,
    _DiagLine = 0x8,
    _Reserved4,
    _Reserved5,
    _Reserved6,
    _Reserved7,
    _Reserved8,
    _Reserved9,
    _Reserved10,
    _Reserved11,
    _Reserved12,
    _Reserved13,
    _Reserved14,
    _Reserved15,
    _None = 0x10000,
    _DontCare = 0x20000,
  };
  enum FixedRate {
    _1MHz,
    _71kHz,
    _10kHz,
    _1kHz,
    _100Hz,
    _10Hz,
    _1Hz,
    _NotFixedRate,
  };
  enum PowerSyncRate {
    _AC60Hz,
    _AC30Hz,
    _AC10Hz,
    _AC5Hz,
    _AC1Hz,
    _NotPowerSyncRate,
  };
  L0SelectV1(TriggerData::L0SelectV1::RateSelect arg__rateSelect, TriggerData::L0SelectV1::FixedRate arg__fixedRate, TriggerData::L0SelectV1::PowerSyncRate arg__powerSyncRate, uint8_t arg__powerSyncMask, uint8_t arg__controlSeqNum, uint8_t arg__controlSeqBit, uint8_t arg__eventCode, uint8_t arg__partition, uint32_t arg__destinations)
    : _rateSelect(arg__rateSelect), _fixedRate(arg__fixedRate), _powerSyncRate(arg__powerSyncRate), _powerSyncMask(arg__powerSyncMask), _controlSeqNum(arg__controlSeqNum), _controlSeqBit(arg__controlSeqBit), _eventCode(arg__eventCode), _partition(arg__partition), _destinations(arg__destinations)
  {
  }
  L0SelectV1(TriggerData::L0SelectV1::FixedRate frate, uint32_t dst)
    : _rateSelect(_FixedRate), _fixedRate(frate), _powerSyncRate(_NotPowerSyncRate), _eventCode(0), _destinations(dst)
  {
  }
  L0SelectV1(TriggerData::L0SelectV1::PowerSyncRate prate, uint8_t pmask, uint32_t dst)
    : _rateSelect(_PowerSyncRate), _fixedRate(_NotFixedRate), _powerSyncRate(prate), _powerSyncMask(pmask), _eventCode(0), _partition(0), _destinations(dst)
  {
  }
  L0SelectV1(uint8_t seqnum, uint8_t seqbit, uint32_t dst)
    : _rateSelect(_ControlSequence), _fixedRate(_NotFixedRate), _powerSyncRate(_NotPowerSyncRate), _controlSeqNum(seqnum), _controlSeqBit(seqbit), _eventCode(0), _partition(0), _destinations(dst)
  {
  }
  L0SelectV1(uint8_t eventCode)
    : _rateSelect(_EventCode), _fixedRate(_NotFixedRate), _powerSyncRate(_NotPowerSyncRate), _controlSeqNum(0), _controlSeqBit(0), _eventCode(eventCode), _partition(0), _destinations(_DontCare)
  {
  }
  L0SelectV1(uint8_t partition, uint32_t dst)
    : _rateSelect(_Partition), _fixedRate(_NotFixedRate), _powerSyncRate(_NotPowerSyncRate), _controlSeqNum(0), _controlSeqBit(0), _eventCode(0), _partition(partition), _destinations(dst)
  {
  }
  L0SelectV1() {}
  TriggerData::L0SelectV1::RateSelect rateSelect() const { return TriggerData::L0SelectV1::RateSelect(_rateSelect); }
  TriggerData::L0SelectV1::FixedRate fixedRate() const { return TriggerData::L0SelectV1::FixedRate(_fixedRate); }
  TriggerData::L0SelectV1::PowerSyncRate powerSyncRate() const { return TriggerData::L0SelectV1::PowerSyncRate(_powerSyncRate); }
  uint8_t powerSyncMask() const { return _powerSyncMask; }
  uint8_t controlSeqNum() const { return _controlSeqNum; }
  uint8_t controlSeqBit() const { return _controlSeqBit; }
  uint8_t eventCode() const { return _eventCode; }
  uint8_t partition() const { return _partition; }
  uint32_t destinations() const { return _destinations; }
  static uint32_t _sizeof() { return 12; }
private:
  uint8_t	_rateSelect;
  uint8_t	_fixedRate;
  uint8_t	_powerSyncRate;
  uint8_t	_powerSyncMask;
  uint8_t	_controlSeqNum;
  uint8_t	_controlSeqBit;
  uint8_t	_eventCode;
  uint8_t	_partition;
  uint32_t	_destinations;
};
std::ostream& operator<<(std::ostream& str, TriggerData::L0SelectV1::RateSelect enval);
std::ostream& operator<<(std::ostream& str, TriggerData::L0SelectV1::Destination enval);
std::ostream& operator<<(std::ostream& str, TriggerData::L0SelectV1::FixedRate enval);
std::ostream& operator<<(std::ostream& str, TriggerData::L0SelectV1::PowerSyncRate enval);
#pragma pack(pop)

/** @class ConfigV1

  
*/


class ConfigV1 {
public:
  enum { TypeId = Pds::TypeId::Id_TriggerConfig /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 1 /**< XTC type version number */ };
  ConfigV1(uint32_t arg__nModules, uint32_t arg__nPartitions, const TriggerData::ModuleV1* arg__modules, const TriggerData::L0SelectV1* arg__l0Select);
  ConfigV1() {}
  ConfigV1(const ConfigV1& other) {
    const char* src = reinterpret_cast<const char*>(&other);
    std::copy(src, src+other._sizeof(), reinterpret_cast<char*>(this));
  }
  ConfigV1& operator=(const ConfigV1& other) {
    const char* src = reinterpret_cast<const char*>(&other);
    std::copy(src, src+other._sizeof(), reinterpret_cast<char*>(this));
    return *this;
  }
  uint32_t nModules() const { return _nModules; }
  uint32_t nPartitions() const { return _nPartitions; }
  /**     Note: this overloaded method accepts shared pointer argument which must point to an object containing
    this instance, the returned ndarray object can be used even after this instance disappears. */
  template <typename T>
  ndarray<const TriggerData::ModuleV1, 1> modules(const boost::shared_ptr<T>& owner) const { 
    ptrdiff_t offset=8;
    const TriggerData::ModuleV1* data = (const TriggerData::ModuleV1*)(((char*)this)+offset);
    return make_ndarray(boost::shared_ptr<const TriggerData::ModuleV1>(owner, data), this->_nModules);
  }
  /**     Note: this method returns ndarray instance which does not control lifetime
    of the data, do not use returned ndarray after this instance disappears. */
  ndarray<const TriggerData::ModuleV1, 1> modules() const { ptrdiff_t offset=8;
  const TriggerData::ModuleV1* data = (const TriggerData::ModuleV1*)(((char*)this)+offset);
  return make_ndarray(data, this->_nModules); }
  /**     Note: this overloaded method accepts shared pointer argument which must point to an object containing
    this instance, the returned ndarray object can be used even after this instance disappears. */
  template <typename T>
  ndarray<const TriggerData::L0SelectV1, 1> l0Select(const boost::shared_ptr<T>& owner) const { 
    ptrdiff_t offset=8+(144*(this->_nModules));
    const TriggerData::L0SelectV1* data = (const TriggerData::L0SelectV1*)(((char*)this)+offset);
    return make_ndarray(boost::shared_ptr<const TriggerData::L0SelectV1>(owner, data), this->_nPartitions);
  }
  /**     Note: this method returns ndarray instance which does not control lifetime
    of the data, do not use returned ndarray after this instance disappears. */
  ndarray<const TriggerData::L0SelectV1, 1> l0Select() const { ptrdiff_t offset=8+(144*(this->_nModules));
  const TriggerData::L0SelectV1* data = (const TriggerData::L0SelectV1*)(((char*)this)+offset);
  return make_ndarray(data, this->_nPartitions); }
  uint32_t _sizeof() const { return (((((8+(TriggerData::ModuleV1::_sizeof()*(this->_nModules)))+(TriggerData::L0SelectV1::_sizeof()*(this->_nPartitions)))+4)-1)/4)*4; }
private:
  uint32_t	_nModules;
  uint32_t	_nPartitions;
  //TriggerData::ModuleV1	_modules[this->_nModules];
  //TriggerData::L0SelectV1	_l0Select[this->_nPartitions];
};
} // namespace TriggerData
} // namespace Pds
#endif // PDS_TRIGGER_DDL_H
