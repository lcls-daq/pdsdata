#ifndef PDS_XPM_DDL_H
#define PDS_XPM_DDL_H 1

// *** Do not edit this file, it is auto-generated ***

#include <vector>
#include <iosfwd>
#include <cstddef>
#include <cstring>
#include "pdsdata/xtc/TypeId.hh"
#include "ndarray/ndarray.h"
#include "pdsdata/xtc/DetInfo.hh"
namespace Pds {
namespace XpmData {

/** @class L0SelectV1

  
*/

#pragma pack(push,4)

class L0SelectV1 {
public:
  enum Source {
    _FixedRate,
    _PowerSyncRate,
    _ControlSequence,
  };
  enum FixedRate {
    _1MHz,
    _200kHz,
    _100kHz,
    _10kHz,
    _1kHz,
    _100Hz,
    _10Hz,
    _1Hz,
    _NotFixedRate,
  };
  enum PowerSyncRate {
    _AC60Hz,
    _AC30Hz,
    _AC10Hz,
    _AC5Hz,
    _AC1Hz,
    _NotPowerSyncRate,
  };
  enum Destination {
    _HXU,
    _SXU,
    _DumpBsy,
    _None,
    _DontCare,
  };
  L0SelectV1(XpmData::L0SelectV1::FixedRate arg__fixedRate, XpmData::L0SelectV1::PowerSyncRate arg__powerSyncRate, uint8_t arg__powerSyncMask, uint8_t arg__controlSeqNum, uint8_t arg__controlSeqBit)
    : _fixedRate(arg__fixedRate), _powerSyncRate(arg__powerSyncRate), _powerSyncMask(arg__powerSyncMask), _controlSeqNum(arg__controlSeqNum), _controlSeqBit(arg__controlSeqBit)
  {
  }
  L0SelectV1(XpmData::L0SelectV1::FixedRate frate, XpmData::L0SelectV1::Destination dst)
    : _source(_FixedRate), _dest(dst), _fixedRate(frate), _powerSyncRate(_NotPowerSyncRate)
  {
  }
  L0SelectV1(XpmData::L0SelectV1::PowerSyncRate prate, uint8_t pmask, XpmData::L0SelectV1::Destination dst)
    : _source(_PowerSyncRate), _dest(dst), _fixedRate(_NotFixedRate), _powerSyncRate(prate), _powerSyncMask(pmask)
  {
  }
  L0SelectV1(uint8_t seqnum, uint8_t seqbit, XpmData::L0SelectV1::Destination dst)
    : _source(_ControlSequence), _dest(dst), _fixedRate(_NotFixedRate), _powerSyncRate(_NotPowerSyncRate), _controlSeqNum(seqnum), _controlSeqBit(seqbit)
  {
  }
  L0SelectV1() {}
  XpmData::L0SelectV1::FixedRate fixedRate() const { return XpmData::L0SelectV1::FixedRate(_fixedRate); }
  XpmData::L0SelectV1::PowerSyncRate powerSyncRate() const { return XpmData::L0SelectV1::PowerSyncRate(_powerSyncRate); }
  uint8_t powerSyncMask() const { return _powerSyncMask; }
  uint8_t controlSeqNum() const { return _controlSeqNum; }
  uint8_t controlSeqBit() const { return _controlSeqBit; }
  static uint32_t _sizeof() { return 7; }
private:
  uint8_t	_source;
  uint8_t	_dest;
  uint8_t	_fixedRate;
  uint8_t	_powerSyncRate;
  uint8_t	_powerSyncMask;
  uint8_t	_controlSeqNum;
  uint8_t	_controlSeqBit;
};
std::ostream& operator<<(std::ostream& str, XpmData::L0SelectV1::Source enval);
std::ostream& operator<<(std::ostream& str, XpmData::L0SelectV1::FixedRate enval);
std::ostream& operator<<(std::ostream& str, XpmData::L0SelectV1::PowerSyncRate enval);
std::ostream& operator<<(std::ostream& str, XpmData::L0SelectV1::Destination enval);
#pragma pack(pop)

/** @class ConfigV1

  
*/


class ConfigV1 {
public:
  enum { TypeId = Pds::TypeId::Id_XpmConfig /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 1 /**< XTC type version number */ };
  ConfigV1(uint32_t arg__nPartitions, const XpmData::L0SelectV1* arg__l0Select);
  ConfigV1() {}
  ConfigV1(const ConfigV1& other) {
    const char* src = reinterpret_cast<const char*>(&other);
    std::copy(src, src+other._sizeof(), reinterpret_cast<char*>(this));
  }
  ConfigV1& operator=(const ConfigV1& other) {
    const char* src = reinterpret_cast<const char*>(&other);
    std::copy(src, src+other._sizeof(), reinterpret_cast<char*>(this));
    return *this;
  }
  uint32_t nPartitions() const { return _nPartitions; }
  /**     Note: this overloaded method accepts shared pointer argument which must point to an object containing
    this instance, the returned ndarray object can be used even after this instance disappears. */
  template <typename T>
  ndarray<const XpmData::L0SelectV1, 1> l0Select(const boost::shared_ptr<T>& owner) const { 
    ptrdiff_t offset=4;
    const XpmData::L0SelectV1* data = (const XpmData::L0SelectV1*)(((char*)this)+offset);
    return make_ndarray(boost::shared_ptr<const XpmData::L0SelectV1>(owner, data), this->_nPartitions);
  }
  /**     Note: this method returns ndarray instance which does not control lifetime
    of the data, do not use returned ndarray after this instance disappears. */
  ndarray<const XpmData::L0SelectV1, 1> l0Select() const { ptrdiff_t offset=4;
  const XpmData::L0SelectV1* data = (const XpmData::L0SelectV1*)(((char*)this)+offset);
  return make_ndarray(data, this->_nPartitions); }
  uint32_t _sizeof() const { return ((((4+(XpmData::L0SelectV1::_sizeof()*(this->_nPartitions)))+4)-1)/4)*4; }
private:
  uint32_t	_nPartitions;
  //XpmData::L0SelectV1	_l0Select[this->_nPartitions];
};
} // namespace XpmData
} // namespace Pds
#endif // PDS_XPM_DDL_H
