#ifndef PDS_TIMETOOL_DDL_H
#define PDS_TIMETOOL_DDL_H 1

// *** Do not edit this file, it is auto-generated ***

#include <vector>
#include <iosfwd>
#include <cstddef>
#include <cstring>
#include "pdsdata/xtc/TypeId.hh"
#include "ndarray/ndarray.h"
#include "pdsdata/psddl/camera.ddl.h"
#include "pdsdata/xtc/Src.hh"
namespace Pds {
namespace TimeTool {

/** @class EventLogic

  
*/

#pragma pack(push,4)

class EventLogic {
public:
  enum LogicOp {
    L_OR = 0,
    L_AND = 1,
    L_OR_NOT = 2,
    L_AND_NOT = 3,
  };
  EventLogic(uint8_t arg__event_code, TimeTool::EventLogic::LogicOp arg__logic_op)
    : _Code(((arg__event_code) & 0xff)|(((arg__logic_op) & 0x3)<<8))
  {
  }
  EventLogic() {}
  /** Event Code */
  uint8_t event_code() const { return uint8_t(this->_Code & 0xff); }
  /** Logic Operation */
  TimeTool::EventLogic::LogicOp logic_op() const { return LogicOp((this->_Code>>8) & 0x3); }
  static uint32_t _sizeof() { return 4; }
private:
  uint32_t	_Code;
};
std::ostream& operator<<(std::ostream& str, TimeTool::EventLogic::LogicOp enval);
#pragma pack(pop)

/** @class ConfigV1

  
*/

#pragma pack(push,4)

class ConfigV1 {
public:
  enum { TypeId = Pds::TypeId::Id_TimeToolConfig /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 1 /**< XTC type version number */ };
  enum Axis {
    X = 0,
    Y = 1,
  };
  ConfigV1(TimeTool::ConfigV1::Axis arg__project_axis, uint8_t arg__write_image, uint8_t arg__write_projections, uint8_t arg__subtract_sideband, uint16_t arg__number_of_weights, uint8_t arg__calib_poly_dim, uint8_t arg__base_name_length, uint16_t arg__number_of_beam_event_codes, uint16_t arg__number_of_laser_event_codes, uint32_t arg__signal_cut, const Camera::FrameCoord& arg__sig_roi_lo, const Camera::FrameCoord& arg__sig_roi_hi, const Camera::FrameCoord& arg__sb_roi_lo, const Camera::FrameCoord& arg__sb_roi_hi, double arg__sb_convergence, double arg__ref_convergence, const TimeTool::EventLogic* arg__beam_logic, const TimeTool::EventLogic* arg__laser_logic, const double* arg__weights, const double* arg__calib_poly, const uint8_t* arg__base_name);
  ConfigV1(uint16_t number_of_beam_event_codes, uint16_t number_of_laser_event_codes, uint16_t number_of_weights, uint8_t calib_poly_dim, uint8_t base_name_length)
    : _Control((((number_of_weights) & 0xffff)<<4)|(((calib_poly_dim) & 0xf)<<20)|(((base_name_length) & 0xff)<<24)), _number_of_beam_event_codes(number_of_beam_event_codes), _number_of_laser_event_codes(number_of_laser_event_codes)
  {
  }
  ConfigV1() {}
  ConfigV1(const ConfigV1& other) {
    const char* src = reinterpret_cast<const char*>(&other);
    std::copy(src, src+other._sizeof(), reinterpret_cast<char*>(this));
  }
  ConfigV1& operator=(const ConfigV1& other) {
    const char* src = reinterpret_cast<const char*>(&other);
    std::copy(src, src+other._sizeof(), reinterpret_cast<char*>(this));
    return *this;
  }
  /** Time Axis of Image */
  TimeTool::ConfigV1::Axis project_axis() const { return Axis(this->_Control & 0x1); }
  /** Record Raw Image into Event */
  uint8_t write_image() const { return uint8_t((this->_Control>>1) & 0x1); }
  /** Record Time Axis Projections into Event */
  uint8_t write_projections() const { return uint8_t((this->_Control>>2) & 0x1); }
  /** Subtract Sideband Region */
  uint8_t subtract_sideband() const { return uint8_t((this->_Control>>3) & 0x1); }
  /** Number of Digital Filter Weights */
  uint16_t number_of_weights() const { return uint16_t((this->_Control>>4) & 0xffff); }
  /** Pixel to Time Calibration Polynomial Dimension */
  uint8_t calib_poly_dim() const { return uint8_t((this->_Control>>20) & 0xf); }
  /** Length of EPICS PV base name */
  uint8_t base_name_length() const { return uint8_t((this->_Control>>24) & 0xff); }
  /** Number of Beam Logic Event Codes */
  uint16_t number_of_beam_event_codes() const { return _number_of_beam_event_codes; }
  /** Number of Laser Logic Event Codes */
  uint16_t number_of_laser_event_codes() const { return _number_of_laser_event_codes; }
  /** Projection Minimum Value for Validation */
  uint32_t signal_cut() const { return _signal_cut; }
  /** Signal Region Coordinates Start */
  const Camera::FrameCoord& sig_roi_lo() const { return _sig_roi_lo; }
  /** Signal Region Coordinates End */
  const Camera::FrameCoord& sig_roi_hi() const { return _sig_roi_hi; }
  /** Sideband Region Coordinates Start */
  const Camera::FrameCoord& sb_roi_lo() const { return _sb_roi_lo; }
  /** Sideband Region Coordinates End */
  const Camera::FrameCoord& sb_roi_hi() const { return _sb_roi_hi; }
  /** Sideband Rolling Average Factor (1/NFrames) */
  double sb_convergence() const { return _sb_convergence; }
  /** Reference Rolling Average Factor (1/NFrames) */
  double ref_convergence() const { return _ref_convergence; }
  /** Beam Logic Event Codes

    Note: this overloaded method accepts shared pointer argument which must point to an object containing
    this instance, the returned ndarray object can be used even after this instance disappears. */
  template <typename T>
  ndarray<const TimeTool::EventLogic, 1> beam_logic(const boost::shared_ptr<T>& owner) const { 
    ptrdiff_t offset=44;
    const TimeTool::EventLogic* data = (const TimeTool::EventLogic*)(((char*)this)+offset);
    return make_ndarray(boost::shared_ptr<const TimeTool::EventLogic>(owner, data), this->number_of_beam_event_codes());
  }
  /** Beam Logic Event Codes

    Note: this method returns ndarray instance which does not control lifetime
    of the data, do not use returned ndarray after this instance disappears. */
  ndarray<const TimeTool::EventLogic, 1> beam_logic() const { ptrdiff_t offset=44;
  const TimeTool::EventLogic* data = (const TimeTool::EventLogic*)(((char*)this)+offset);
  return make_ndarray(data, this->number_of_beam_event_codes()); }
  /** Laser Logic Event Codes

    Note: this overloaded method accepts shared pointer argument which must point to an object containing
    this instance, the returned ndarray object can be used even after this instance disappears. */
  template <typename T>
  ndarray<const TimeTool::EventLogic, 1> laser_logic(const boost::shared_ptr<T>& owner) const { 
    ptrdiff_t offset=44+(4*(this->number_of_beam_event_codes()));
    const TimeTool::EventLogic* data = (const TimeTool::EventLogic*)(((char*)this)+offset);
    return make_ndarray(boost::shared_ptr<const TimeTool::EventLogic>(owner, data), this->number_of_laser_event_codes());
  }
  /** Laser Logic Event Codes

    Note: this method returns ndarray instance which does not control lifetime
    of the data, do not use returned ndarray after this instance disappears. */
  ndarray<const TimeTool::EventLogic, 1> laser_logic() const { ptrdiff_t offset=44+(4*(this->number_of_beam_event_codes()));
  const TimeTool::EventLogic* data = (const TimeTool::EventLogic*)(((char*)this)+offset);
  return make_ndarray(data, this->number_of_laser_event_codes()); }
  /** Digital Filter Weights

    Note: this overloaded method accepts shared pointer argument which must point to an object containing
    this instance, the returned ndarray object can be used even after this instance disappears. */
  template <typename T>
  ndarray<const double, 1> weights(const boost::shared_ptr<T>& owner) const { 
    ptrdiff_t offset=(44+(4*(this->number_of_beam_event_codes())))+(4*(this->number_of_laser_event_codes()));
    const double* data = (const double*)(((char*)this)+offset);
    return make_ndarray(boost::shared_ptr<const double>(owner, data), this->number_of_weights());
  }
  /** Digital Filter Weights

    Note: this method returns ndarray instance which does not control lifetime
    of the data, do not use returned ndarray after this instance disappears. */
  ndarray<const double, 1> weights() const { ptrdiff_t offset=(44+(4*(this->number_of_beam_event_codes())))+(4*(this->number_of_laser_event_codes()));
  const double* data = (const double*)(((char*)this)+offset);
  return make_ndarray(data, this->number_of_weights()); }
  /** Pixel to Time Calibration Polynomial

    Note: this overloaded method accepts shared pointer argument which must point to an object containing
    this instance, the returned ndarray object can be used even after this instance disappears. */
  template <typename T>
  ndarray<const double, 1> calib_poly(const boost::shared_ptr<T>& owner) const { 
    ptrdiff_t offset=((44+(4*(this->number_of_beam_event_codes())))+(4*(this->number_of_laser_event_codes())))+(8*(this->number_of_weights()));
    const double* data = (const double*)(((char*)this)+offset);
    return make_ndarray(boost::shared_ptr<const double>(owner, data), this->calib_poly_dim());
  }
  /** Pixel to Time Calibration Polynomial

    Note: this method returns ndarray instance which does not control lifetime
    of the data, do not use returned ndarray after this instance disappears. */
  ndarray<const double, 1> calib_poly() const { ptrdiff_t offset=((44+(4*(this->number_of_beam_event_codes())))+(4*(this->number_of_laser_event_codes())))+(8*(this->number_of_weights()));
  const double* data = (const double*)(((char*)this)+offset);
  return make_ndarray(data, this->calib_poly_dim()); }
  /** EPICS PV base name

    Note: this overloaded method accepts shared pointer argument which must point to an object containing
    this instance, the returned ndarray object can be used even after this instance disappears. */
  template <typename T>
  ndarray<const uint8_t, 1> base_name(const boost::shared_ptr<T>& owner) const { 
    ptrdiff_t offset=(((44+(4*(this->number_of_beam_event_codes())))+(4*(this->number_of_laser_event_codes())))+(8*(this->number_of_weights())))+(8*(this->calib_poly_dim()));
    const uint8_t* data = (const uint8_t*)(((char*)this)+offset);
    return make_ndarray(boost::shared_ptr<const uint8_t>(owner, data), this->base_name_length());
  }
  /** EPICS PV base name

    Note: this method returns ndarray instance which does not control lifetime
    of the data, do not use returned ndarray after this instance disappears. */
  ndarray<const uint8_t, 1> base_name() const { ptrdiff_t offset=(((44+(4*(this->number_of_beam_event_codes())))+(4*(this->number_of_laser_event_codes())))+(8*(this->number_of_weights())))+(8*(this->calib_poly_dim()));
  const uint8_t* data = (const uint8_t*)(((char*)this)+offset);
  return make_ndarray(data, this->base_name_length()); }
  uint32_t _sizeof() const { return ((((((((((((((12+(Camera::FrameCoord::_sizeof()))+(Camera::FrameCoord::_sizeof()))+(Camera::FrameCoord::_sizeof()))+(Camera::FrameCoord::_sizeof()))+8)+8)+(TimeTool::EventLogic::_sizeof()*(this->number_of_beam_event_codes())))+(TimeTool::EventLogic::_sizeof()*(this->number_of_laser_event_codes())))+(8*(this->number_of_weights())))+(8*(this->calib_poly_dim())))+(1*(this->base_name_length())))+4)-1)/4)*4; }
private:
  uint32_t	_Control;
  uint16_t	_number_of_beam_event_codes;	/**< Number of Beam Logic Event Codes */
  uint16_t	_number_of_laser_event_codes;	/**< Number of Laser Logic Event Codes */
  uint32_t	_signal_cut;	/**< Projection Minimum Value for Validation */
  Camera::FrameCoord	_sig_roi_lo;	/**< Signal Region Coordinates Start */
  Camera::FrameCoord	_sig_roi_hi;	/**< Signal Region Coordinates End */
  Camera::FrameCoord	_sb_roi_lo;	/**< Sideband Region Coordinates Start */
  Camera::FrameCoord	_sb_roi_hi;	/**< Sideband Region Coordinates End */
  double	_sb_convergence;	/**< Sideband Rolling Average Factor (1/NFrames) */
  double	_ref_convergence;	/**< Reference Rolling Average Factor (1/NFrames) */
  //TimeTool::EventLogic	_beam_logic[this->number_of_beam_event_codes()];
  //TimeTool::EventLogic	_laser_logic[this->number_of_laser_event_codes()];
  //double	_weights[this->number_of_weights()];
  //double	_calib_poly[this->calib_poly_dim()];
  //uint8_t	_base_name[this->base_name_length()];
};
std::ostream& operator<<(std::ostream& str, TimeTool::ConfigV1::Axis enval);
#pragma pack(pop)
} // namespace TimeTool
} // namespace Pds
#endif // PDS_TIMETOOL_DDL_H
